<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en"><generator uri="https://jekyllrb.com/" version="4.4.1">Jekyll</generator><link href="https://nearground.github.io/feed.xml" rel="self" type="application/atom+xml"/><link href="https://nearground.github.io/" rel="alternate" type="text/html" hreflang="en"/><updated>2025-08-03T03:58:56+00:00</updated><id>https://nearground.github.io/feed.xml</id><title type="html">blank</title><subtitle>This is my personal website, where I keep my blog, portfolio, details on current projects, and my bookshelf </subtitle><entry><title type="html">Eigenvectors and Eigenvalues</title><link href="https://nearground.github.io/blog/2025/eigenvectors-and-eigenvalues/" rel="alternate" type="text/html" title="Eigenvectors and Eigenvalues"/><published>2025-08-02T07:37:00+00:00</published><updated>2025-08-02T07:37:00+00:00</updated><id>https://nearground.github.io/blog/2025/eigenvectors-and-eigenvalues</id><content type="html" xml:base="https://nearground.github.io/blog/2025/eigenvectors-and-eigenvalues/"><![CDATA[<p>Statistics deals with finding order out of chaos. One field where chaos reigns and there is much more than meets the eye is the field of hyperspectral imaging in chemometrics.</p> <p>In the field of chemometrics, hyperspectral cameras are sometimes used to capture a broad spectrum of wavelengths of objects of interest in order to extract features from them. Think of it as a photograph that records values from infrared up to ulraviolet. Whereas a regular image has three color values for each pixel (R,G,B) a hyperspectral image may contain hundreds of variables, each representing a narrow spectral band. With more variables, more information. However, with more variables, there is also exponentially more complexity. This is called the <em>CURSE OF DIMENSIONALITY</em>. In order to avoid this fate, we use techniques for <em>dimensionality reduction</em>. That is, reducing the amount of variables down to just the most important ones. The techniques for achieving this fall under the umbrella of what is termed <em>Spectral Theory</em>. Spooky, but not so cursed.</p> <div class="row mt-3 mt-md-0 rounded mx-auto d-block"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/Hyperspectral_image_data_cube-480.webp 480w,/assets/img/Hyperspectral_image_data_cube-800.webp 800w,/assets/img/Hyperspectral_image_data_cube-1400.webp 1400w," type="image/webp" sizes="95vw"/> <img src="/assets/img/Hyperspectral_image_data_cube.jpg" class="img-fluid rounded z-depth-1" width="100%" height="auto" title="too many dimensions!" loading="lazy" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> <div class="caption"> A hyperspectral image, also called a hypercube </div> <h1 id="spectral-theory">Spectral Theory</h1> <p><a href="https://en.wikipedia.org/wiki/Spectral_theory">Wikipedia</a>:</p> <blockquote> <p>In mathematics, spectral theory is an inclusive term for theories extending the eigenvector and eigenvalue theory of a single square matrix to a much broader theory of the structure of operators in a variety of mathematical spaces.</p> </blockquote> <h1 id="eigenvalues-and-eigenvectors">Eigenvalues and Eigenvectors</h1> <p>Consider an MxN matrix A of M datapoints with N variables each. The eigenvectors of the matrix describe the perpendicular directions over which the datapoints are spread out. Mathematically speaking, they are vectors such that Av = Œªv, where Œª is their eigenvalue. They‚Äôre special vector that, when transformed by a matrix, only changes in length (gets stretched or shrunk) but not in direction. The amount by which they shrink or stretch is the eigenvalue.</p> <p>To find the eigenvectors of a matrix, first find the eigenvalues by solving the characteristic equation <code class="language-plaintext highlighter-rouge">det(A - ŒªI) = 0</code>, where A is the matrix, Œª is the eigenvalue, I is the identity matrix, and <strong>0</strong> is the zero vector. Knowing the eigenvalues, we then solve for <code class="language-plaintext highlighter-rouge">(A-ŒªI)x=0</code>, where the possible solutions for the vector x are the eigenvectors.</p> <div class="row mt-3 mt-md-0 rounded mx-auto d-block"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/eigenvector-480.webp 480w,/assets/img/eigenvector-800.webp 800w,/assets/img/eigenvector-1400.webp 1400w," type="image/webp" sizes="95vw"/> <img src="/assets/img/eigenvector.jpg" class="img-fluid rounded z-depth-1" width="100%" height="auto" title="stretched dog" loading="lazy" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> <div class="caption"> Woo-o-f! </div> <p>One algorithm that leverages eigenvectors and eigenvalues for effective dimensionality reduction is called Principal Component Analysis (PCA).</p> <h1 id="principal-component-analysis">Principal Component Analysis</h1> <p>From <a href="https://fritz.ai/demystifying-principal-component-analysis-handling-the-curse-of-dimensionality/">Fritz‚Äô Blog</a></p> <blockquote> <p>Principal component analysis (PCA) is an algorithm that uses a statistical procedure to convert a set of observations of possibly correlated variables into a set of values of linearly uncorrelated variables called principal components. [‚Ä¶] This is one of the primary methods for performing dimensionality reduction ‚Äî this reduction ensures that the new dimension maintains the original variance in the data as best it can. [‚Ä¶] That way we can visualize high-dimensional data in 2D or 3D, or use it in a machine learning algorithm for faster training and inference.</p> </blockquote> <p>They also lay out the steps for performing PCA.</p> <ol> <li>Standardize (or normalize) the data: involves usually applying a mask to the image. A mask is simply filtering out all the outliers in the dataset i.e. shiny things, scribbles on the image, calibration strips, etc. This is up to the expertise of the researcher/engineer.</li> <li>Calculate the covariance matrix from this standardized data (with dimension d).</li> <li>Obtain the Eigenvectors and Eigenvalues from the newly-calculated covariance matrix.</li> <li>Sort the Eigenvalues in descending order, and choose the ùëò Eigenvectors that correspond to the ùëò largest Eigenvalues ‚Äî where ùëò is the number of dimensions in the new feature subspace (ùëò‚â§ùëë).</li> <li>Construct the projection matrix ùëä from the ùëò selected Eigenvectors.</li> <li>Transform the original dataset ùëã by simple multiplication in ùëä to obtain a ùëò-dimensional feature subspace ùëå.</li> <li>(optional) Calculate the explained variance: how much variance is captured by the PCA algorithm. Higher value = better.</li> </ol> <p>PCA has its own limitations. Mainly, that it doesn‚Äôt work so well with non-linear correlations. Luckily, you can always apply your own kernel methods for translating polynomial relationships down to linear problems, but that‚Äôs a horror story for another time.</p> <p>I‚Äôll lay out the rest of the steps soon in a new post on how to implement PCA from scratch.</p>]]></content><author><name></name></author><category term="fun"/><category term="work"/><category term="mathematics"/><category term="statistics"/><category term="linear-algebra"/><summary type="html"><![CDATA[Building up to Principal Component Analysis]]></summary></entry><entry><title type="html">Understanding ConvChain</title><link href="https://nearground.github.io/blog/2025/understanding-convchain/" rel="alternate" type="text/html" title="Understanding ConvChain"/><published>2025-08-02T00:51:00+00:00</published><updated>2025-08-02T00:51:00+00:00</updated><id>https://nearground.github.io/blog/2025/understanding-convchain</id><content type="html" xml:base="https://nearground.github.io/blog/2025/understanding-convchain/"><![CDATA[<p>I‚Äôd always wanted to know how videogame designers often make infinite worlds for players to explore, or how rogue-like games such as Diablo create levels.</p> <div class="row mt-3 mt-md-0 rounded mx-auto d-block"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/d2-map-480.webp 480w,/assets/img/d2-map-800.webp 800w,/assets/img/d2-map-1400.webp 1400w," type="image/webp" sizes="95vw"/> <img src="/assets/img/d2-map.jpg.jpg" class="img-fluid rounded z-depth-1" width="100%" height="auto" title="The den of evil!" loading="lazy" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> <div class="caption"> A core memory of my childhood: Navigating Diablo II's randomly-generated maps </div> <p>The technique for creating random patterns is called procedural generation, and my first real introduction to it came, thanks to reddit, through a technique called <a href="https://github.com/mxgmn/WaveFunctionCollapse">Wave Function Collapse</a>, created by Maxim Gumin in like 2016.</p> <div class="row mt-3 mt-md-0 rounded mx-auto d-block"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/wfc-480.webp 480w,/assets/img/wfc-800.webp 800w,/assets/img/wfc-1400.webp 1400w," type="image/webp" sizes="95vw"/> <img src="/assets/img/wfc.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" title="The wave function collapse algorithm" loading="lazy" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> <div class="caption"> The Wave Function Collapse algorithm takes in a sample image, extracts patterns out of it, defines adjacency rules for them, and recreates an image using said patterns and adjacencies. </div> <p>The algorithm seemed quite simple and I will make its own post soon, however I just couldn‚Äôt wrap my head around the implementation. I decided to start with an earlier algorithm of Gumin‚Äôs called <a href="https://github.com/mxgmn/ConvChain">ConvChain</a>.</p> <h2 id="the-convchain-algorithm">The ConvChain algorithm</h2> <p><em>ConvChain is a Markov chain of images that converges to input-like images. That is, the distribution of NxN patterns in the outputs converges to the distribution of NxN patterns in the input as the process goes on.</em></p> <p>At its core, the ConvChain algorithm is itself an implementation of the Metropolis-Hastings algorithm.</p> <p>The interactive version that I added to the bottom of the page was ported to javascript and optimized with WebGL by <a href="https://github.com/kchapelier">Kevin Chapelier</a>. I have made very minimal changes to the algorithm, mainly in how arrays are sorted, as I <em>think</em> there was a mistake in how it‚Äôs implemented. It doesn‚Äôt actually seem to impact accuracy all that much, though, but I thought I‚Äôd leave the changes there.</p> <h3 id="the-metropolis-hastings-algorithm">The Metropolis-Hastings Algorithm</h3> <blockquote> <p><a href="https://en.wikipedia.org/wiki/Metropolis%E2%80%93Hastings_algorithm">Wikipedia</a>: a Markov chain Monte Carlo (MCMC) method for obtaining a sequence of random samples from a probability distribution from which direct sampling is difficult. New samples are added to the sequence in two steps: first a new sample is proposed based on the previous sample, then the proposed sample is either added to the sequence or rejected depending on the value of the probability distribution at that point.</p> </blockquote> <blockquote> <p>The Metropolis‚ÄìHastings algorithm generates a sequence of sample values in such a way that, as more and more sample values are produced, the distribution of values more closely approximates the desired distribution. These sample values are produced iteratively in such a way, that the distribution of the next sample depends only on the current sample value, which makes the sequence of samples a Markov chain.</p> </blockquote> <p>The crux of the algorithm goes like this:</p> <ol> <li>Read the input image and count NxN patterns. (optional) Augment pattern data with rotations and reflections.</li> <li>Initialize the image (for example, with independent random values) in some state S0.</li> <li>Repeat the Metropolis step: Compute the energy E of the current state S. Choose a random pixel and change its value. Let‚Äôs call the resulting state S‚Äô. Compute the energy E‚Äô of the state S‚Äô. Compare E‚Äô to E. If E‚Äô &lt; E assign the current state to be E‚Äô. Otherwise, assign the current state to be E‚Äô with probability <code class="language-plaintext highlighter-rouge">exp(-(E'-E)/T)</code>.</li> </ol> <p>S is the current state of any pixel. In his implementation, pixels can be either white or black (0, or 1). Energy is computed via an equation that I will describe later. T stands for temperature, a parameter that can be tweaked to determine how often a value can flip between 0 and 1.</p> <p>Let‚Äôs dive into the code.</p> <h2 id="step-0-the-beginning">Step 0: The Beginning</h2> <div class="language-c# highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">static</span> <span class="kt">bool</span><span class="p">[,]</span> <span class="nf">ConvChain</span><span class="p">(</span><span class="kt">bool</span><span class="p">[,]</span> <span class="n">sample</span><span class="p">,</span> <span class="kt">int</span> <span class="n">N</span><span class="p">,</span> <span class="kt">double</span> <span class="n">temperature</span><span class="p">,</span> <span class="kt">int</span> <span class="n">size</span><span class="p">,</span> <span class="kt">int</span> <span class="n">iterations</span><span class="p">)</span>
<span class="p">{</span>
  <span class="kt">bool</span><span class="p">[,]</span> <span class="n">field</span> <span class="p">=</span> <span class="k">new</span> <span class="kt">bool</span><span class="p">[</span><span class="n">size</span><span class="p">,</span> <span class="n">size</span><span class="p">];</span> <span class="c1">// the array of our final output</span>
  <span class="kt">double</span><span class="p">[]</span> <span class="n">weights</span> <span class="p">=</span> <span class="k">new</span> <span class="kt">double</span><span class="p">[</span><span class="m">1</span> <span class="p">&lt;&lt;</span> <span class="p">(</span><span class="n">N</span> <span class="p">*</span> <span class="n">N</span><span class="p">)];</span> <span class="c1">//This is where we will store the count of each pattern.</span>
  <span class="n">Random</span> <span class="n">random</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">Random</span><span class="p">();</span> <span class="c1">//the magical hat where we draw numbers from</span>
</code></pre></div></div> <p>This is the beginning of the main function. We have a boolean 2D array called <code class="language-plaintext highlighter-rouge">sample</code>, the size <code class="language-plaintext highlighter-rouge">N</code> of the patterns that we will extract from the input image, the <code class="language-plaintext highlighter-rouge">temperature</code> parameter that affects how frequently a given pixel flips between 0 and 1, the <code class="language-plaintext highlighter-rouge">size</code> of our output image, and the number of <code class="language-plaintext highlighter-rouge">iterations</code> the algorithm will run for. Internally, it uses an array named <code class="language-plaintext highlighter-rouge">field</code> that will become the final output, and <code class="language-plaintext highlighter-rouge">weights</code>, where we will count the amount of times each pattern appears in our input and thus its probability distribution. It then will return a 2D array (<code class="language-plaintext highlighter-rouge">bool[,]</code>).</p> <h3 id="t-is-for-temperature">T is for Temperature</h3> <p>Temperature is a variable that we can tweak so that we can directly adjust the probability of a pixel being replaced by a new value. It changes the probability distribution of the state S to <code class="language-plaintext highlighter-rouge">p(S) ~ exp(-E(S)/T)</code></p> <h3 id="why-1-n--n">Why 1 ¬´¬†(N * N)?</h3> <p>The expression means ‚Äúbitwise shift left the number 1 to the left N*N times‚Äù. Bitwise shifting left means converting the number to binary, adding zeroes to the right of it and computing the end result. 1, in binary, is 2 to the power of zero, (<em>rock fact: that‚Äôs why programmers count from zero</em>) and each zero you tack on to the right adds a power to that 2. So, the code reads ‚Äúweights is an array of size 2^n*n‚Äù in common parlance, but really we‚Äôre working with bits here:</p> <p>Consider an n-sized binary array. It has n*n elements, each 0 or 1. All the combinations possible for the array can fit a binary number with n*n zeros to the right of it, e.g. b10000 for n = 2, or 2^(2*2)=16 in decimal, thus 1 ¬´¬†N*N. We will use <code class="language-plaintext highlighter-rouge">weight</code> to count how often often each pattern shows up.</p> <h2 id="step-1-read-the-input-image-and-count-nxn-patterns">Step 1: Read the input image and count NxN patterns.</h2> <h4 id="and-also-augment-pattern-data-with-rotations-and-reflections">‚Ä¶And also augment pattern data with rotations and reflections:</h4> <div class="language-c# highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">//for each point in the input, get eight patterns</span>
<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">y</span> <span class="p">=</span> <span class="m">0</span><span class="p">;</span> <span class="n">y</span> <span class="p">&lt;</span> <span class="n">sample</span><span class="p">.</span><span class="nf">GetLength</span><span class="p">(</span><span class="m">1</span><span class="p">);</span> <span class="n">y</span><span class="p">++)</span> <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">x</span> <span class="p">=</span> <span class="m">0</span><span class="p">;</span> <span class="n">x</span> <span class="p">&lt;</span> <span class="n">sample</span><span class="p">.</span><span class="nf">GetLength</span><span class="p">(</span><span class="m">0</span><span class="p">);</span> <span class="n">x</span><span class="p">++)</span>
  <span class="p">{</span>
    <span class="c1">//The array of Patterns where we'll store them</span>
    <span class="n">Pattern</span><span class="p">[]</span> <span class="n">p</span> <span class="p">=</span> <span class="k">new</span> <span class="n">Pattern</span><span class="p">[</span><span class="m">8</span><span class="p">];</span>
    <span class="c1">//Get the eight patterns mentioned before.</span>
    <span class="c1">//No special logic here except for the custom class Pattern which I'll hand-wave away *whoosh*.</span>
    <span class="c1">//Just take it as the pattern of size N that starts at coords (x,y) in the sample array.</span>
    <span class="n">p</span><span class="p">[</span><span class="m">0</span><span class="p">]</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">Pattern</span><span class="p">(</span><span class="n">sample</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">N</span><span class="p">);</span>
    <span class="n">p</span><span class="p">[</span><span class="m">1</span><span class="p">]</span> <span class="p">=</span> <span class="n">p</span><span class="p">[</span><span class="m">0</span><span class="p">].</span><span class="nf">Rotated</span><span class="p">();</span>
    <span class="n">p</span><span class="p">[</span><span class="m">2</span><span class="p">]</span> <span class="p">=</span> <span class="n">p</span><span class="p">[</span><span class="m">1</span><span class="p">].</span><span class="nf">Rotated</span><span class="p">();</span>
    <span class="n">p</span><span class="p">[</span><span class="m">3</span><span class="p">]</span> <span class="p">=</span> <span class="n">p</span><span class="p">[</span><span class="m">2</span><span class="p">].</span><span class="nf">Rotated</span><span class="p">();</span>
    <span class="n">p</span><span class="p">[</span><span class="m">4</span><span class="p">]</span> <span class="p">=</span> <span class="n">p</span><span class="p">[</span><span class="m">0</span><span class="p">].</span><span class="nf">Reflected</span><span class="p">();</span>
    <span class="n">p</span><span class="p">[</span><span class="m">5</span><span class="p">]</span> <span class="p">=</span> <span class="n">p</span><span class="p">[</span><span class="m">1</span><span class="p">].</span><span class="nf">Reflected</span><span class="p">();</span>
    <span class="n">p</span><span class="p">[</span><span class="m">6</span><span class="p">]</span> <span class="p">=</span> <span class="n">p</span><span class="p">[</span><span class="m">2</span><span class="p">].</span><span class="nf">Reflected</span><span class="p">();</span>
    <span class="n">p</span><span class="p">[</span><span class="m">7</span><span class="p">]</span> <span class="p">=</span> <span class="n">p</span><span class="p">[</span><span class="m">3</span><span class="p">].</span><span class="nf">Reflected</span><span class="p">();</span>
    <span class="c1">// each transformation of the pattern gets its own count.</span>
    <span class="c1">// It's my intuition that at the end of the day they all get the same amount of counts.</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">k</span> <span class="p">=</span> <span class="m">0</span><span class="p">;</span> <span class="n">k</span> <span class="p">&lt;</span> <span class="m">8</span><span class="p">;</span> <span class="n">k</span><span class="p">++)</span> <span class="n">weights</span><span class="p">[</span><span class="n">p</span><span class="p">[</span><span class="n">k</span><span class="p">].</span><span class="nf">Index</span><span class="p">()]</span> <span class="p">+=</span> <span class="m">1</span><span class="p">;</span>
  <span class="p">}</span>
<span class="c1">//using 0.1 instead of 0 makes it so that an energy state is never 0 *whoosh*.</span>
<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">k</span> <span class="p">=</span> <span class="m">0</span><span class="p">;</span> <span class="n">k</span> <span class="p">&lt;</span> <span class="n">weights</span><span class="p">.</span><span class="n">Length</span><span class="p">;</span> <span class="n">k</span><span class="p">++)</span> <span class="k">if</span> <span class="p">(</span><span class="n">weights</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="p">&lt;=</span> <span class="m">0</span><span class="p">)</span> <span class="n">weights</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="p">=</span> <span class="m">0.1</span><span class="p">;</span>
</code></pre></div></div> <p>We iterate over each pixel in the input, read N pixels ahead and above to make an NxN array (the algorithm wraps around the image if there aren‚Äôt enough pixels), rotate four times and get the mirror of each pattern (thus getting eight patterns total per pixel). For each pattern created this way, we compute its index in the weights array and increase its count by 1. Finally, all the patterns that weren‚Äôt found in this way are set to 0.1 from 0, because we‚Äôll be computing energy states by multiplying counts together and they can‚Äôt be non-zero (this will make sense later). The index function is interesting, so I‚Äôll explain that as well:</p> <h3 id="the-index-method">The Index method</h3> <div class="language-c# highlighter-rouge"><div class="highlight"><pre class="highlight"><code>	<span class="k">public</span> <span class="kt">int</span> <span class="nf">Index</span><span class="p">()</span>
	<span class="p">{</span>
		<span class="kt">int</span> <span class="n">result</span> <span class="p">=</span> <span class="m">0</span><span class="p">;</span>
    <span class="c1">///Size() is just the size of the input array</span>
		<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">y</span> <span class="p">=</span> <span class="m">0</span><span class="p">;</span> <span class="n">y</span> <span class="p">&lt;</span> <span class="nf">Size</span><span class="p">();</span> <span class="n">y</span><span class="p">++)</span> <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">x</span> <span class="p">=</span> <span class="m">0</span><span class="p">;</span> <span class="n">x</span> <span class="p">&lt;</span> <span class="nf">Size</span><span class="p">();</span> <span class="n">x</span><span class="p">++)</span> <span class="n">result</span> <span class="p">+=</span> <span class="n">data</span><span class="p">[</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">]</span> <span class="p">?</span> <span class="m">1</span> <span class="p">&lt;&lt;</span> <span class="p">(</span><span class="n">y</span> <span class="p">*</span> <span class="nf">Size</span><span class="p">()</span> <span class="p">+</span> <span class="n">x</span><span class="p">)</span> <span class="p">:</span> <span class="m">0</span><span class="p">;</span>
		<span class="k">return</span> <span class="n">result</span><span class="p">;</span>
	<span class="p">}</span>
</code></pre></div></div> <p>Remember how we calculated the weights array size with bitwise shifting? This method uses the same technique to turn the binary array into a number. Another way to do this would be to just concatenate them as strings, casting them to binary, then to decimal.</p> <h2 id="step-2-initialize-the-image-with-independent-random-values">Step 2: Initialize the image with independent random values.</h2> <p>This one is trivial: Just fill the array randomly with 1‚Äôs and 0‚Äôs.</p> <div class="language-c# highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">y</span> <span class="p">=</span> <span class="m">0</span><span class="p">;</span> <span class="n">y</span> <span class="p">&lt;</span> <span class="n">size</span><span class="p">;</span> <span class="n">y</span><span class="p">++)</span> <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">x</span> <span class="p">=</span> <span class="m">0</span><span class="p">;</span> <span class="n">x</span> <span class="p">&lt;</span> <span class="n">size</span><span class="p">;</span> <span class="n">x</span><span class="p">++)</span> <span class="n">field</span><span class="p">[</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">]</span> <span class="p">=</span> <span class="n">random</span><span class="p">.</span><span class="nf">Next</span><span class="p">(</span><span class="m">2</span><span class="p">)</span> <span class="p">==</span> <span class="m">1</span><span class="p">;</span>
</code></pre></div></div> <h2 id="step-3-repeat-the-metropolis-step">Step 3: Repeat the Metropolis step</h2> <p>Initialize the metropolis algorithm in a random pixel, and run it enough times so that approximately every pixel in a square image of size <code class="language-plaintext highlighter-rouge">size</code> gets iterated on <code class="language-plaintext highlighter-rouge">iterations</code> times.</p> <div class="language-c# highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">k</span> <span class="p">=</span> <span class="m">0</span><span class="p">;</span> <span class="n">k</span> <span class="p">&lt;</span> <span class="n">iterations</span> <span class="p">*</span> <span class="n">size</span> <span class="p">*</span> <span class="n">size</span><span class="p">;</span> <span class="n">k</span><span class="p">++)</span> <span class="nf">metropolis</span><span class="p">(</span><span class="n">random</span><span class="p">.</span><span class="nf">Next</span><span class="p">(</span><span class="n">size</span><span class="p">),</span> <span class="n">random</span><span class="p">.</span><span class="nf">Next</span><span class="p">(</span><span class="n">size</span><span class="p">));</span>
</code></pre></div></div> <h3 id="the-metropolis-hastings-algorithm-1">The Metropolis-Hastings algorithm</h3> <p>The Metropolis step refers to the Metropolis-Hastings algorithm for getting a random sample out of a probability distribution. From (Wikipedia):</p> <blockquote> <p><em>First a new sample is proposed based on the previous sample, then the proposed sample is either added to the sequence or rejected depending on the value of the probability distribution at that point. The resulting sequence can be used to approximate the distribution (e.g. to generate a histogram) or to compute an integral (e.g. an expected value).</em></p> </blockquote> <p>In the code it looks like this:</p> <div class="language-c# highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">void</span> <span class="nf">metropolis</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="kt">int</span> <span class="n">j</span><span class="p">)</span>
<span class="p">{</span>
  <span class="kt">double</span> <span class="n">p</span> <span class="p">=</span> <span class="nf">energyExp</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">);</span> <span class="c1">//Calculate the energy state of the given pixel at i,j. This is E in the original description</span>
  <span class="n">field</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="p">=</span> <span class="p">!</span><span class="n">field</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">];</span> <span class="c1">//flip the bit at i,j</span>
  <span class="kt">double</span> <span class="n">q</span> <span class="p">=</span> <span class="nf">energyExp</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">);</span> <span class="c1">// Re-calculate the energy state of the now-switched pixel at i,j. This is E' in the original description</span>
  <span class="c1">//If q &gt; p, keep the changes, otherwise randomly revert the changes with P = exp(-(E'-E)/T)</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">Math</span><span class="p">.</span><span class="nf">Pow</span><span class="p">(</span><span class="n">q</span> <span class="p">/</span> <span class="n">p</span><span class="p">,</span> <span class="m">1.0</span> <span class="p">/</span> <span class="n">temperature</span><span class="p">)</span> <span class="p">&lt;</span> <span class="n">random</span><span class="p">.</span><span class="nf">NextDouble</span><span class="p">())</span> <span class="n">field</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="p">=</span> <span class="p">!</span><span class="n">field</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">];</span>
<span class="p">};</span>
</code></pre></div></div> <p>If E‚Äô(1/p) is smaller than E (1/q), then we keep that bit flipped (assuming temperature is less than 1). Otherwise, flip it back with probability <code class="language-plaintext highlighter-rouge">(q/p)^(-t)</code>. Let‚Äôs talk more about the energy function:</p> <h3 id="e-is-for-energy">E is for energy</h3> <p>ExUtumno introduces the energy function as <code class="language-plaintext highlighter-rouge">E(S) := - sum over all patterns P in S of log(weight(P))</code> because in the metropolis part of his algorithm he uses <code class="language-plaintext highlighter-rouge">exp(-(E'-E)/T)</code>. Remember our weight array and how it was used for storing pattern counts? Turns out we actually interpret pattern counts as the log of their probability weight. This describes a log-normal distribution.</p> <h3 id="the-log-normal-distribution">The Log-Normal Distribution</h3> <blockquote> <p>A log-normal process is the statistical realization of the <em>multiplicative product</em> of many independent random variables, each of which is positive. This is justified by considering the central limit theorem in the log domain (sometimes called Gibrat‚Äôs law). <a href="https://en.wikipedia.org/wiki/Log-normal_distribution">The log-normal distribution</a> is the maximum entropy probability distribution for a random variate X‚Äîfor which the mean and variance of ln X are specified.</p> </blockquote> <p>Anyway, here‚Äôs the energy function. Hold out your hand, it‚Äôs quite cool:</p> <div class="language-c# highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">double</span> <span class="nf">energyExp</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="kt">int</span> <span class="n">j</span><span class="p">)</span>
<span class="p">{</span>
  <span class="kt">double</span> <span class="k">value</span> <span class="p">=</span> <span class="m">1.0</span><span class="p">;</span>
  <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">y</span> <span class="p">=</span> <span class="n">j</span> <span class="p">-</span> <span class="n">N</span> <span class="p">+</span> <span class="m">1</span><span class="p">;</span> <span class="n">y</span> <span class="p">&lt;=</span> <span class="n">j</span> <span class="p">+</span> <span class="n">N</span> <span class="p">-</span> <span class="m">1</span><span class="p">;</span> <span class="n">y</span><span class="p">++)</span> <span class="err">\</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">x</span> <span class="p">=</span> <span class="n">i</span> <span class="p">-</span> <span class="n">N</span> <span class="p">+</span> <span class="m">1</span><span class="p">;</span> <span class="n">x</span> <span class="p">&lt;=</span> <span class="n">i</span> <span class="p">+</span> <span class="n">N</span> <span class="p">-</span> <span class="m">1</span><span class="p">;</span> <span class="n">x</span><span class="p">++)</span> <span class="err">\</span>
      <span class="k">value</span> <span class="p">*=</span> <span class="n">weights</span><span class="p">[</span><span class="k">new</span> <span class="nf">Pattern</span><span class="p">(</span><span class="n">field</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">N</span><span class="p">).</span><span class="nf">Index</span><span class="p">()];</span>
  <span class="k">return</span> <span class="k">value</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></div></div> <p>And how it‚Äôs used in the metropolis algorithm:</p> <div class="language-c# highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="c1">//If q &gt; p, keep the changes, otherwise randomly revert the changes with P = exp(-(E'-E)/T)</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">Math</span><span class="p">.</span><span class="nf">Pow</span><span class="p">(</span><span class="n">q</span> <span class="p">/</span> <span class="n">p</span><span class="p">,</span> <span class="m">1.0</span> <span class="p">/</span> <span class="n">temperature</span><span class="p">)</span> <span class="p">&lt;</span> <span class="n">random</span><span class="p">.</span><span class="nf">NextDouble</span><span class="p">())</span> <span class="n">field</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="p">=</span> <span class="p">!</span><span class="n">field</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">];</span>
</code></pre></div></div> <p>Remember the energy function is the negative sum of the logs of probability weights. Via log properties, this means that the exponential of the energy function will return 1/the product of their counts. When you calculate <code class="language-plaintext highlighter-rouge">exp(-(E'-E)/T)</code> you get <code class="language-plaintext highlighter-rouge">(q/p)^(1/temperature)</code>. when q/p is greater than one and temperature is less than one, you will always keep the bit flipped i.e. move towards a lower entropy state. Otherwise, probability kicks in depending on the magnitude of difference between states, and how ‚Äúhot‚Äù the model is.</p> <p>So that explains the Metropolis algorithm implementation. We can now return our output image and call it a day</p> <h2 id="finally">Finally</h2> <div class="language-c# highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">//the end result</span>
<span class="k">return</span> <span class="n">field</span><span class="p">;</span>
</code></pre></div></div> <p><em>Don‚Äôt forget to like and subscribe!</em> Oh, and don‚Äôt forget to check out this interactive version (shoutout again to K. Chapelier).</p> <p>‚î≥‚îÅ‚î≥ „ÉΩ(‡≤†ŸÑÕú‡≤†)„Éé</p> <div class="convchain-example row"> <div class="left-panel col-sm"> <h1 clas="row d-flex align-items-center justify-content-center">ConvChain GPU example</h1> <h2 class="row d-flex align-items-center justify-content-center">Sample pattern</h2> <div class="row "> <div class="col d-flex align-items-center justify-content-center"> <div class="sample-container"> <canvas id="samplePattern" width="8" height="8" style="position:absolute; top: 50%; left: 50%; transform:translate(-50%, -50%); width:80px; height:80px; image-rendering: pixelated;"></canvas> </div> </div> </div> <div class="row d-flex align-items-center justify-content-center"> <button id="clear" class="col-xs-1" style="padding: 10px 0;"> Clear </button> </div> <h2>Options</h2> <form class="flex-column align-items-center justify-content-center"> <div class="field option"> <label for="sampleWidth">Sample width</label> <input type="range" id="sampleWidth" min="4" max="24" step="1" value="8"/> <span class="value">8</span> </div> <div class="field option"> <label for="sampleHeight">Sample height</label> <input type="range" id="sampleHeight" min="4" max="24" step="1" value="8"/> <span class="value">8</span> </div> <div class="field option"> <label for="receptorSize">Receptor size (n)</label> <input type="range" id="receptorSize" min="2" max="4" step="1" value="3"/> <span class="value">3</span> </div> <div class="field option"> <label for="temperature">Temperature</label> <input type="range" id="temperature" min="0" max="0.5" value="0.01" step="0.001"/> <span class="value">0.01</span> </div> </form> </div> <div class="right-panel col-sm"> <h2>Generated patterns </h2> (iteration #<span id="iteration">0 + 0000</span> changes) <div class="buttons"> <button id="play">Start</button> <button id="next">Next</button> <button id="reset">Reset</button> </div> <div class="convchain-canvas"></div> </div> <script>
(function(f){if(typeof exports==="object"&&typeof module!=="undefined"){module.exports=f()}else if(typeof define==="function"&&define.amd){define([],f)}else{var g;if(typeof window!=="undefined"){g=window}else if(typeof global!=="undefined"){g=global}else if(typeof self!=="undefined"){g=self}else{g=this}g.ConvChainGPU = f()}})(function(){var define,module,exports;return (function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c="function"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error("Cannot find module '"+i+"'");throw a.code="MODULE_NOT_FOUND",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u="function"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()({1:[function(require,module,exports){
"use strict";

const Context = require('./webgl2/context');

/**
 * ConvChainGPU constructor.
 *
 * @param {Array|Uint8Array} sample Sample pattern as a flat array or a 2D array.
 * @param {int} [sampleSize] Indicate the width and height of the sample when used with a flat array, if omitted assume the sample is a square
 * @constructor
 */
function ConvChainGPU (sample, sampleSize) {
  this.context = new Context();

  this.textureWeights = null;
  this.texturesField = null;

  this.width = 16;
  this.height = 16;

  this.createProgram();
  this.setSample(sample, sampleSize);
}

/**
 * Create the program used to execute the convchain algorithm.
 *
 * @private
 */
ConvChainGPU.prototype.createProgram = function () {
  this.program = this.context.createProgram(
    `
    in vec3 position;

    void main() {
        gl_Position = vec4(position, 1.0);
    }
    `,
    `
    layout(location = 0) out vec4 fragColor;

    uniform sampler2D weights;
    uniform sampler2D field;
    uniform vec2 resolution;
    uniform float temperature;
    uniform float n;
    uniform float iteration;
    uniform float seed;

    #define rng() fract(seed * iteration * iteration * 0.1981 + 1. + sin(seed * 1453. + dot(gl_FragCoord.xy, vec2(12.9898, 4.1414 + sin(seed * 4801. + iteration*0.1393)))) * 43758.5453)
    #define pixelPicking(n,coord,frame) (mod(floor(n*n*0.5+1.)*frame, n*n) == mod(floor(coord.x), n) + mod(floor(coord.y), n) * n)

    #define getFieldValue(coord) round(mod(texelFetch(field, ivec2(coord.xy), 0).r + 0.00001, 2.))
    #define getRawFieldValue(coord) round(texelFetch(field, ivec2(coord.xy), 0).r + 0.00001)
    #define getWeightValue(index) texelFetch(weights, ivec2(mod(index, 1024.), floor((index) / 1024.)), 0).r

    float convchain (vec2 coord) {
      float q = 1.;
      float value = getRawFieldValue(coord);

      for (float syo = 1. - n; syo <= n - 1.; syo++) {
        for (float sxo = 1. - n; sxo <= n - 1.; sxo++) {
          float ind = 0.;
          float difference = 0.;

          for (float dy = 0.; dy < n; dy++) {
            for (float dx = 0.; dx < n; dx++) {
              float power = pow(2., dy * n + dx);
              vec2 ncoord = mod(coord + vec2(sxo + dx, syo + dy) + resolution.xy, resolution.xy);

              float nvalue = getFieldValue(ncoord);

              ind = ind + nvalue * power;

              if (ncoord.xy == coord.xy) {
                difference = mix(-power, power, nvalue);
              }
            }
          }

          q = q * getWeightValue(ind - difference) / getWeightValue(ind);
        }
      }

      if (value < 1.5 && pow(q, 1. / temperature) > rng()) {
        value = abs(value - 1.);
      }

      return value;
    }

    void main () {
      fragColor = pixelPicking(n, gl_FragCoord, iteration) ?
        vec4(convchain(floor(gl_FragCoord.xy)), 0., 0., 1.) :
        vec4(getRawFieldValue(floor(gl_FragCoord.xy)), 0., 0., 1.);
    }
    `,
    {
      resolution: '2f',
      weights: 't',
      field: 't',
      temperature: 'f',
      n: 'f',
      iteration: 'f',
      seed: 'f'
    }
  );
};

/**
 * Set the sample pattern
 * @param {Array|Uint8Array} sample Sample pattern as a flat array or a 2D array
 * @param {int|Array} [sampleSize] When used with a flat array indicate the width and height of the sample, if omitted assume the sample is a square
 *
 * @return {ConvChainGPU} Return self.
 */
ConvChainGPU.prototype.setSample = function (sample, sampleSize) {
  if (typeof sample[0] === 'number') {
    // assume flat array
    this.sample = sample;

    if (!sampleSize) {
      // assume square sample

      this.sampleWidth = this.sampleHeight = Math.sqrt(sample.length) | 0;
    } else {
      this.sampleWidth = typeof sampleSize === 'number' ? sampleSize : sampleSize[0];
      this.sampleHeight = typeof sampleSize === 'number' ? sampleSize : sampleSize[1];
    }
  } else {
    // assume 2D array
    this.sampleWidth = sample[0].length;
    this.sampleHeight = sample.length;

    const flatArray = new Uint8Array(this.sampleWidth * this.sampleHeight);

    for (let y = 0; y < this.sampleHeight; y++) {
      for (let x = 0; x < this.sampleWidth; x++) {
        flatArray[x + y * this.sampleWidth] = sample[y][x];
      }
    }

    this.sample = flatArray;
  }

  // invalidate cached weights
  this.cachedN = null;

  return this;
};

function processWeights (context, sample, sampleWidth, sampleHeight, n) {
  const count = (1 << (n * n)); //equivalent to 2^n^n.
  const width = Math.min(1024, count);
  const height = Math.max(1, count / width); 

  const weights = new Float32Array(4 * width * height);

  function pattern (fn) { //utility function for rotation, reflection, etc
    const result = new Array(n * n);

    for (let y = 0; y < n; y++) {
      for (let x = 0; x < n; x++) {
        result[x + y * n] = fn(x, y);
      }
    }

    return result;
  }

  function rotate (p) {
    return pattern(function (x, y) { return p[n - 1 - y + x * n]; });
  }

  function reflect (p) {
    return pattern(function (x, y) { return p[n - 1 - x + y * n]; });
  }

  function index (p) {
    let result = 0;
    let power = 1;

    for (let i = 0; i < p.length; i++) {
      result += p[p.length - 1 - i] ? power : 0;
      power *= 2;
    }

    return result;
  }

  for (let y = 0; y < sampleHeight; y++) {
    for (let x = 0; x < sampleWidth; x++) {
      const p0 = pattern(function (dx, dy) { return sample[((x + dx) % sampleWidth) + ((y + dy) % sampleHeight) * sampleHeight]; });
      const p1 = rotate(p0);
      const p2 = rotate(p1);
      const p3 = rotate(p2);
      const p4 = reflect(p0);
      const p5 = reflect(p1);
      const p6 = reflect(p2);
      const p7 = reflect(p3);

      weights[index(p0) * 4] += 1;
      weights[index(p1) * 4] += 1;
      weights[index(p2) * 4] += 1;
      weights[index(p3) * 4] += 1;
      weights[index(p4) * 4] += 1;
      weights[index(p5) * 4] += 1;
      weights[index(p6) * 4] += 1;
      weights[index(p7) * 4] += 1;
    }
  }

  for (let k = 0; k < count; k++) {
    if (weights[k * 4] <= 0) {
      weights[k * 4] = 0.1;
    }
  }

  return context.createTextureFromArray(weights, width, height, false);
}

/**
 * Get the weights for the sample pattern and the given receptor size.
 *
 * @param {int} n Receptor size, an integer in the range [2, 4].
 * @returns {Texture}
 * @private
 */
ConvChainGPU.prototype.getWeights = function (n) {
  if (n < 2 || n > 4) {
    throw new Error('ConvChainGPU: the receptor size must be in the [2, 4] range.')
  }
  // check if we have to generate new weights, otherwise return cached result
  if (this.cachedN !== n) {
    if (this.textureWeights) {
      this.textureWeights.dispose();
    }

    this.cachedN = n;
    this.textureWeights = processWeights(this.context, this.sample, this.sampleWidth, this.sampleHeight, n);
  }

  return this.textureWeights;
};

function generateBaseField (ctx, resultWidth, resultHeight) {
  const field = new Float32Array(resultWidth * resultHeight * 4);

  for (let i = 0; i < resultWidth * resultHeight; i++) {
    field[i * 4] = Math.random() < 0.5; // R
  }

  return [
    ctx.createTextureFromArray(field, resultWidth, resultHeight, true),
    ctx.createTextureFromArray(field, resultWidth, resultHeight, true)
  ];
}

/**
 * Set the field ConvChain should be applied on.
 *
 * @param {int} width Width of the field.
 * @param {int} height Height of the field.
 * @param {Uint8Array|Array} [values] Values to populate the field with.
 * @returns {ConvChainGPU} Return self.
 * @public
 */
ConvChainGPU.prototype.setField = function (width, height, values) {
  if (values && values.length !== width * height) {
    throw new Error('ConvChainGPU: Incorrect size for provided values.');
  }

  if (width < 4) {
    throw new Error('ConvChainGPU: Field width must be > 3.');
  }

  if (height < 4) {
    throw new Error('ConvChainGPU: Field height must be > 3.');
  }

  if (this.texturesField) {
    this.texturesField[0].dispose();
    this.texturesField[1].dispose();
    this.texturesField = null;
  }

  this.iteration = 0;
  this.width = width | 0;
  this.height = height | 0;

  if (values) {
    const field = new Float32Array(this.width * this.height * 4);

    for (let i = 0; i < this.width * this.height; i++) {
      field[i * 4] = Math.max(0, Math.round(values[(i % this.width) + (this.height - (i / this.width | 0) - 1) * this.width])); // R
    }

    this.texturesField = [
      this.context.createTextureFromArray(field, this.width, this.height, true),
      this.context.createTextureFromArray(field, this.width, this.height, true)
    ];
  }

  return this;
};

/**
 * Apply ConvChain on the field.
 *
 * @param {int} iterations Number of iterations to execute.
 * @param {int} n Receptor size, an integer in the range [2,4].
 * @param {float} temperature Temperature.
 * @param {float} [seed=0] Seed.
 * @returns {Texture} Generated pattern, returned as an object with the following methods : getUint8Array and getTexture.
 * @public
 */
ConvChainGPU.prototype.iterate = function (iterations, n, temperature, seed) {
  if (this.texturesField === null) {
    this.texturesField = generateBaseField(this.context, this.width, this.height);
  }

  seed = seed || 0;

  const textureWeights = this.getWeights(n);

  let frontTexture;
  let backTexture;

  for (let i = 0; i < iterations; i++) {
    frontTexture = this.texturesField[this.iteration%2];
    backTexture = this.texturesField[(this.iteration+1)%2];

    this.context.draw(
      this.program,
      {
        field: backTexture,
        weights: textureWeights,
        resolution: [this.width, this.height],
        temperature: temperature,
        n: n,
        iteration: this.iteration,
        seed: seed
      },
      frontTexture
    );

    this.iteration++;
  }

  return frontTexture;
};

/**
 * Free all the WebGL resources used by this instance.
 */
ConvChainGPU.prototype.dispose = function () {
  if (this.context) {
    if (this.texturesField) {
      this.texturesField[0].dispose();
      this.texturesField[1].dispose();
    }

    if (this.textureWeights) {
      this.textureWeights.dispose();
    }

    this.program.dispose();

    this.context.dispose();

    this.texturesField = null;
    this.context = null;
    this.textureWeights = null;
    this.program = null;
  }
};

/**
 * Returns whether the current environment supports all the feature necessary to use ConvChainGPU.
 *
 * @returns {boolean}
 */
ConvChainGPU.isSupported = function () {
  return Context.isSupported();
};

module.exports = ConvChainGPU;
},{"./webgl2/context":2}],2:[function(require,module,exports){
"use strict";

const Texture = require('./texture');
const Program = require('./program');

const planePositions = new Float32Array([-1, -1, 0, -1, 4, 0, 4, -1, 0]);

/**
 *
 * @constructor
 */
function Context () {
  this.canvas = document.createElement('canvas');
  this.width = this.canvas.width = this.height = this.canvas.height = 32;

  const options = {
    alpha: false,
    antialias: false,
    depth: false,
    stencil: false,
    powerPreference: 'high-performance',
    premultipliedAlpha: false,
    preserveDrawingBuffer: false
  };

  this.context = this.canvas.getContext('webgl2', options);
  this.context.getExtension('EXT_color_buffer_float');

  this.context.disable(this.context.DITHER);
  this.context.disable(this.context.DEPTH_TEST);
  this.context.disable(this.context.BLEND);

  // 1x1 opaque black texture
  this.defaultTexture = this.context.createTexture();
  this.context.bindTexture(this.context.TEXTURE_2D, this.defaultTexture);
  this.context.texImage2D(this.context.TEXTURE_2D, 0, this.context.RGBA, 1, 1, 0, this.context.RGBA, this.context.UNSIGNED_BYTE, new Uint8Array([0, 0, 0, 1]));
  this.context.texParameteri(this.context.TEXTURE_2D, this.context.TEXTURE_MAG_FILTER, this.context.NEAREST);
  this.context.texParameteri(this.context.TEXTURE_2D, this.context.TEXTURE_MIN_FILTER, this.context.NEAREST);

  this.positionBuffer = this.context.createBuffer();
  this.context.bindBuffer(this.context.ARRAY_BUFFER, this.positionBuffer);
  this.context.bufferData(this.context.ARRAY_BUFFER, planePositions, this.context.STATIC_DRAW);
}

/**
 * Update the size of the canvas.
 */
Context.prototype.setCanvasSize = function (width, height) {
  this.width = this.canvas.width = width;
  this.height = this.canvas.height = height;
  this.context.viewport(0, 0, this.width, this.height);
};

/**
 * Draw using the given program.
 *
 * @param {Program} program
 * @param {object} uniforms
 * @param {Texture|null}target
 */
Context.prototype.draw = function (program, uniforms, target) {
  if (target) {
    this.context.viewport(0, 0, target.width, target.height);
    this.context.bindFramebuffer(this.context.FRAMEBUFFER, target.getFrameBuffer());
  } else {
    this.context.viewport(0, 0, this.width, this.height);
    this.context.bindFramebuffer(this.context.FRAMEBUFFER, null);
  }

  if (this.lastUsedProgram !== program) {
    this.context.useProgram(program.getProgram());
    this.lastUsedProgram = program;
  }

  for (let i = 0; i < program.uniformsInfo.length; i++) {
    const uniform = program.uniformsInfo[i];
    const typeOfValue = typeof uniforms[uniform.id];
    const uniformValue = typeOfValue === 'undefined' ? uniform.defaultValue : uniforms[uniform.id];

    this.context[uniform.method].apply(this.context, [uniform.location].concat(uniformValue));
  }

  for (let i = 0; i < program.texturesInfo.length; i++) {
    const texture = program.texturesInfo[i];
    const textureValue = uniforms[texture.id];

    this.context.activeTexture(texture.textureUnit);
    this.context.bindTexture(this.context.TEXTURE_2D, textureValue && textureValue.isReady() ? textureValue.getTexture() : this.defaultTexture);
    this.context.uniform1i(texture.location, texture.textureNumber);
  }

  this.context.vertexAttribPointer(program.positionAttribute, 3, this.context.FLOAT, false, 0, 0);

  this.context.drawArrays(this.context.TRIANGLES, 0, 3);

  this.context.finish();
};

/**
 * Load an standard texture from an url.
 *
 * @param {string} url
 *
 * @returns {Texture}
 */
Context.prototype.loadTextureImage = function(url) {
  const texture = new Texture(this.context);

  const img = document.createElement('img');
  img.onload = () => {
    texture.initializeFromImage(img);
  };
  img.src = url;

  return texture;
};

/**
 * Create a texture from an array of values.
 *
 * @param {Float32Array} floatArray
 * @param {int} width
 * @param {int} height
 * @param {boolean} withFrameBuffer
 *
 * @returns {Texture}
 */
Context.prototype.createTextureFromArray = function (floatArray, width, height, withFrameBuffer) {
  const texture = new Texture(this.context);

  texture.initializeFromArray(floatArray, width, height, withFrameBuffer);

  return texture;
};

/**
 * Create program.
 *
 * @param {string} vertexShader
 * @param {string} fragmentShader
 * @param {object} uniforms
 *
 * @returns {Program}
 */
Context.prototype.createProgram = function (vertexShader, fragmentShader, uniforms) {
  return new Program(this.context, vertexShader, fragmentShader, uniforms);
};


Context.prototype.dispose = function () {
  const loseContextExt = this.context.getExtension('WEBGL_lose_context');

  this.context.deleteBuffer(this.positionBuffer);

  if (loseContextExt) {
    loseContextExt.loseContext();
  }

  this.positionBuffer = null;
  this.context = null;
};

/**
 * Check whether WebGl is supported on the device.
 *
 * @returns {boolean}
 */
Context.isSupported = function () {
  const canvas = document.createElement('canvas');
  canvas.width = canvas.height = 32;

  const context = canvas.getContext('webgl2');
  const colorBufferFloatExt = context ? context.getExtension('EXT_color_buffer_float') : null;
  const loseContextExt = context ? context.getExtension('WEBGL_lose_context') : null;

  const success = !!context && !!colorBufferFloatExt;

  if (loseContextExt) {
    loseContextExt.loseContext();
  }

  return success;
};

module.exports = Context;
},{"./program":3,"./texture":4}],3:[function(require,module,exports){
"use strict";

const types = {
  'f': {
    method: 'uniform1f',
    defaultValue: 0
  },
  '2f': {
    method: 'uniform2f',
    defaultValue: [0, 0]
  },
  '3f': {
    method: 'uniform3f',
    defaultValue: [0, 0, 0]
  },
  '4f': {
    method: 'uniform4f',
    defaultValue: [0, 0, 0, 0]
  }
};

/**
 *
 * @param {WebGLRenderingContext} context
 * @param {string} vertexShaderSrc
 * @param {string} fragmentShaderSrc
 * @param {object} uniforms
 * @param {object} defines
 *
 * @constructor
 */
function Program (context, vertexShaderSrc, fragmentShaderSrc, uniforms, defines) {
  this.context = context;
  this.initialize(vertexShaderSrc, fragmentShaderSrc, uniforms, defines);
}

/**
 * Initialize the shaders and program.
 *
 * @param {string} vertexShaderSrc
 * @param {string} fragmentShaderSrc
 * @param {object} uniforms
 * @param {object} defines
 *
 * @protected
 */
Program.prototype.initialize = function (vertexShaderSrc, fragmentShaderSrc, uniforms) {
  const quality = 'highp';

  vertexShaderSrc = `#version 300 es
    precision ${quality} float;
    precision ${quality} int;

    ${vertexShaderSrc}
  `;

  fragmentShaderSrc = `#version 300 es
    precision ${quality} float;
    precision ${quality} int;
    precision ${quality} sampler2D;

    ${fragmentShaderSrc}
  `;

  this.vertexShader = this.createShader(this.context.VERTEX_SHADER, vertexShaderSrc);
  this.fragmentShader = this.createShader(this.context.FRAGMENT_SHADER, fragmentShaderSrc);
  this.program = this.context.createProgram();

  this.context.attachShader(this.program, this.vertexShader);
  this.context.attachShader(this.program, this.fragmentShader);

  this.context.linkProgram(this.program);
  //this.context.validateProgram(this.program); //throw warning in firefox on mac

  //if (!this.context.getProgramParameter(this.program, this.context.LINK_STATUS)) {
  //  throw new Error('Could not initialise shaders: ' + this.context.getProgramInfoLog(this.program));
  //}

  const uniformsKeys = Object.keys(uniforms);
  this.uniformsInfo = [];
  this.texturesInfo = [];
  let textureNumber = 0;

  for (let i = 0; i < uniformsKeys.length; i++) {
    const uniform = uniformsKeys[i];
    const type = uniforms[uniform];

    if (type === 't') {
      this.texturesInfo.push({
        id: uniform,
        textureNumber: textureNumber,
        textureUnit: this.context['TEXTURE' + textureNumber],
        location: this.context.getUniformLocation(this.program, uniform)
      });

      textureNumber++;
    } else {
      this.uniformsInfo.push({
        id: uniform,
        method: types[type].method,
        defaultValue: types[type].defaultValue,
        location: this.context.getUniformLocation(this.program, uniform)
      });
    }
  }

  this.positionAttribute = this.context.getAttribLocation(this.program, 'position');
  this.context.enableVertexAttribArray(this.positionAttribute);
};


/**
 * Create a shader.
 *
 * @param {int} type FRAGMENT_SHADER or VERTEX_SHADER
 * @param {string} src Source of the shader
 * @returns {WebGLShader}
 */
Program.prototype.createShader = function (type, src) {
  const shader = this.context.createShader(type);
  this.context.shaderSource(shader, src);
  this.context.compileShader(shader);

  if (!this.context.getShaderParameter(shader, this.context.COMPILE_STATUS)) {
    throw new Error('Error creating shader : ' + this.context.getShaderInfoLog(shader) + '\n' + src);
  }

  return shader;
};

/**
 * Retrieve the WebGLProgram.
 *
 * @returns {WebGLProgram}
 * @public
 */
Program.prototype.getProgram = function () {
  return this.program;
};

/**
 * Free the resources used for the program.
 *
 * @public
 */
Program.prototype.dispose = function () {
  this.context.deleteProgram(this.program);
  this.context.deleteShader(this.vertexShader);
  this.context.deleteShader(this.fragmentShader);

  this.program = null;
  this.vertexShader = null;
  this.fragmentShader = null;
  this.context = null;
};

module.exports = Program;
},{}],4:[function(require,module,exports){
"use strict";

/**
 *
 * @param {WebGLRenderingContext} context
 *
 * @constructor
 */
function Texture (context) {
  this.context = context;
  this.ready = false;
  this.floatArray = null;
}

/**
 * Initialize the texture with a loaded image.
 *
 * @param img
 */
Texture.prototype.initializeFromImage = function (img) {
  if (this.context !== null) {
    this.width = img.naturalWidth || img.width;
    this.height = img.naturalHeight || img.height;
    this.texture = this.context.createTexture();
    this.context.bindTexture(this.context.TEXTURE_2D, this.texture);
    this.context.pixelStorei(this.context.UNPACK_FLIP_Y_WEBGL, true);
    this.context.texImage2D(this.context.TEXTURE_2D, 0, this.context.RGBA, this.context.RGBA, this.context.UNSIGNED_BYTE, img);
    this.context.pixelStorei(this.context.UNPACK_FLIP_Y_WEBGL, false);

    this.context.texParameteri(this.context.TEXTURE_2D, this.context.TEXTURE_WRAP_S, this.context.CLAMP_TO_EDGE);
    this.context.texParameteri(this.context.TEXTURE_2D, this.context.TEXTURE_WRAP_T, this.context.CLAMP_TO_EDGE);
    this.context.texParameteri(this.context.TEXTURE_2D, this.context.TEXTURE_MAG_FILTER, this.context.LINEAR);
    this.context.texParameteri(this.context.TEXTURE_2D, this.context.TEXTURE_MIN_FILTER, this.context.LINEAR);

    this.context.bindTexture(this.context.TEXTURE_2D, null);
    this.ready = true;
  }
};

/**
 * Initialize the texture with an array of float values.
 *
 * @param {Float32Array} floatArray
 * @param {int} width
 * @param {int} height
 * @param {boolean} withFrameBuffer
 */
Texture.prototype.initializeFromArray = function (floatArray, width, height, withFrameBuffer) {
  if (this.context !== null) {
    this.width = width;
    this.height = height;
    this.texture = this.context.createTexture();
    this.context.bindTexture(this.context.TEXTURE_2D, this.texture);
    this.context.pixelStorei(this.context.UNPACK_FLIP_Y_WEBGL, false);
    this.context.texImage2D(this.context.TEXTURE_2D, 0, this.context.RGBA32F, this.width, this.height, 0, this.context.RGBA, this.context.FLOAT, floatArray);

    this.context.texParameteri(this.context.TEXTURE_2D, this.context.TEXTURE_WRAP_S, this.context.CLAMP_TO_EDGE);
    this.context.texParameteri(this.context.TEXTURE_2D, this.context.TEXTURE_WRAP_T, this.context.CLAMP_TO_EDGE);
    this.context.texParameteri(this.context.TEXTURE_2D, this.context.TEXTURE_MAG_FILTER, this.context.NEAREST);
    this.context.texParameteri(this.context.TEXTURE_2D, this.context.TEXTURE_MIN_FILTER, this.context.NEAREST);

    if (withFrameBuffer) {
      this.frameBuffer = this.context.createFramebuffer();
      this.context.bindFramebuffer(this.context.FRAMEBUFFER, this.frameBuffer);
      this.context.framebufferTexture2D(this.context.FRAMEBUFFER, this.context.COLOR_ATTACHMENT0, this.context.TEXTURE_2D, this.texture, 0);
      this.context.bindFramebuffer(this.context.FRAMEBUFFER, null);
    }

    this.context.bindTexture(this.context.TEXTURE_2D, null);
    this.ready = true;
  }
};

/**
 * Retrieve the result as a Uint8Array.
 *
 * @returns {Uint8Array}
 * @public
 */
Texture.prototype.getUint8Array = function () {
  const floatArrayLength = 4 * this.width * this.height;
  const floatArray = (this.floatArray && this.floatArray.length === floatArrayLength) ? this.floatArray : new Float32Array(4 * this.width * this.height);
  const resultArray = new Uint8Array(this.width * this.height);

  this.context.bindFramebuffer(this.context.FRAMEBUFFER, this.frameBuffer);
  this.context.readPixels(0, 0, this.width, this.height, this.context.RGBA, this.context.FLOAT, floatArray, 0);
  this.context.bindFramebuffer(this.context.FRAMEBUFFER, null);

  for (let i = 0; i < resultArray.length; i++) {
    resultArray[(i % this.width) + (this.height - (i / this.width | 0) - 1) * this.width] = Math.round(floatArray[i * 4]);
  }

  this.floatArray = floatArray;

  return resultArray;
};

/**
 * Check whether the texture is ready to be used.
 *
 * @returns {boolean|*}
 */
Texture.prototype.isReady = function () {
  return this.ready;
};

/**
 * Return the texture.
 *
 * @returns {WebGLTexture|null}
 */
Texture.prototype.getTexture = function () {
  return this.texture;
};

/**
 * Return the framebuffer
 *
 * @returns {WebGLFramebuffer}
 */
Texture.prototype.getFrameBuffer = function () {
  return this.frameBuffer;
};

/**
 * Free the resources used for the texture.
 *
 * @public
 */
Texture.prototype.dispose = function () {
  if (this.frameBuffer) {
    this.context.deleteFramebuffer(this.frameBuffer);
  }

  this.context.deleteTexture(this.texture);

  this.texture = null;
  this.frameBuffer = null;
  this.context = null;
};

module.exports = Texture;
},{}]},{},[1])(1)
});
if(!ConvChainGPU.isSupported()) {

  alert('Your browser does not implement the required features to run ConvChainGPU');

} else {

  const options = {
    receptorSize: 3,
    temperature: 0.01,
    changes: 32,
    sampleWidth: 8,
    sampleHeight: 8,
    useTiles: 0
  };

  let previousSampleWidth = 8;
  let previousSampleHeight = 8;

  let sample = [
    1, 0, 0, 0, 0, 0, 0, 1,
    1, 0, 1, 1, 1, 1, 1, 1,
    1, 0, 0, 0, 0, 0, 0, 1,
    1, 0, 1, 1, 0, 1, 0, 1,
    1, 0, 1, 1, 0, 0, 0, 1,
    1, 0, 1, 1, 0, 1, 0, 1,
    1, 0, 0, 0, 0, 0, 0, 1,
    1, 1, 1, 1, 1, 1, 1, 1
  ]; //2D array

  const convchain = new ConvChainGPU(sample);
  convchain.setField(40, 40);
  document.querySelector('.convchain-canvas').appendChild(convchain.context.canvas);

  var samplePattern = document.getElementById('samplePattern'),
    sampleContext = samplePattern.getContext('2d'),
    drawMode = null;

  var resizeSample = function resizeSample () {
    var previousTestSample = sample;

    samplePattern.width = options.sampleWidth;
    samplePattern.height = options.sampleHeight;

    samplePattern.style.width = options.sampleWidth * 10 + 'px';
    samplePattern.style.height = options.sampleHeight * 10 + 'px';

    sample = new Array(options.sampleWidth * options.sampleHeight);

    sampleContext.fillStyle = '#000000';
    sampleContext.fillRect(0, 0, options.sampleWidth, options.sampleHeight);
    sampleContext.fillStyle = '#FFFFFF';

    for (var x = 0; x < options.sampleWidth; x++) {
      for (var y = 0; y < options.sampleHeight; y++) {
        if (x < previousSampleWidth && y < previousSampleHeight && previousTestSample[x + y * previousSampleWidth]) {
          sample[x + y * options.sampleWidth] = 1;
          sampleContext.fillRect(x, y, 1, 1);
        } else {
          sample[x + y * options.sampleWidth] = 0;
        }
      }
    }

    previousSampleWidth = options.sampleWidth;
    previousSampleHeight = options.sampleHeight;

    convchain.setSample(sample, [options.sampleWidth, options.sampleHeight]);
  };

  resizeSample();

  samplePattern.addEventListener('mousedown', function (e) {
    const x = e.offsetX / 10 | 0;
    const y = e.offsetY / 10 | 0;

    drawMode = (!sample[x + y * options.sampleWidth] ? 1 : 0);

    sample[x + y * options.sampleWidth] = drawMode;

    sampleContext.fillStyle = drawMode ? "#FFFFFF" : "#000000";

    sampleContext.fillRect(x, y, 1, 1);
  });

  function stopDrawMode () {
    if (drawMode !== null) {
      drawMode = null;
      convchain.setSample(sample, [options.sampleWidth, options.sampleHeight]);
    }
  }

  samplePattern.addEventListener('mouseup', stopDrawMode);
  samplePattern.addEventListener('mouseleave', stopDrawMode);

  samplePattern.addEventListener('mousemove', function (e) {
    if (drawMode !== null) {
      var x = e.offsetX / 10 | 0,
        y = e.offsetY / 10 | 0;

      sample[x + y * options.sampleWidth] = drawMode;
      sampleContext.fillRect(x, y, 1, 1);
    }
  });

  document.getElementById('clear').addEventListener('click', function () {
    for (var i = 0; i < sample.length; i++) {
      sample[i] = 0;
    }

    sampleContext.fillStyle = '#000000';
    sampleContext.fillRect(0, 0, options.sampleWidth, options.sampleHeight);

    convchain.setSample(sample, [options.sampleWidth, options.sampleHeight]);
  });

  var textureTiles1 = convchain.context.loadTextureImage('./dungeon_tiles-reduced.png');
  var textureTiles2 = convchain.context.loadTextureImage('./dungeon_tiles-reduced2.png');

  var program = convchain.context.createProgram(
    `
    in vec3 position;

    void main() {
      gl_Position = vec4(position, 1.0);
    }
    `,
    `
    #define rng() fract(40.3299 * sin(dot(floor(gl_FragCoord.xy / 16.), vec2(5.43939, 4.4938))))
    #define value(x, y) (mod(texelFetch(backgroundTexture, ivec2(gl_FragCoord.xy / 16.) + ivec2(x, y), 0).r + 0.0001, 2.) > 0.5)

    layout(location = 0) out vec4 fragColor;

    uniform sampler2D backgroundTexture;
    uniform sampler2D textureTiles;
    uniform vec2 resolution;
    uniform float useTiles;

    const ivec2 voidTile = ivec2(3, 0);
    const ivec2 voidTileVar1 = ivec2(4, 0);
    const ivec2 fallTile = ivec2(0, 1);
    const ivec2 fallTileVar1 = ivec2(1, 1);
    const ivec2 groundTile = ivec2(1, 3);
    const ivec2 groundTileVar1 = ivec2(3, 5);

    const ivec2 cornerDL = ivec2(0, 2);
    const ivec2 edgeD = ivec2(1, 2);
    const ivec2 edgeDVar1 = ivec2(2, 2);
    const ivec2 edgeDVar2 = ivec2(3, 2);
    const ivec2 cornerDR = ivec2(4, 2);

    const ivec2 edgeL = ivec2(0, 5);
    const ivec2 edgeLVar1 = ivec2(0, 4);
    const ivec2 edgeLVar2 = ivec2(0, 3);

    const ivec2 edgeR = ivec2(4, 5);
    const ivec2 edgeRVar1 = ivec2(4, 4);
    const ivec2 edgeRVar2 = ivec2(4, 3);

    const ivec2 cornerUL = ivec2(0, 6);
    const ivec2 edgeU = ivec2(1, 6);
    const ivec2 edgeUVar1 = ivec2(2, 6);
    const ivec2 edgeUVar2 = ivec2(3, 6);
    const ivec2 cornerUR = ivec2(4, 6);

    const ivec2 lineV = ivec2(5, 5);
    const ivec2 lineH = ivec2(6, 6);

    const ivec2 endL = ivec2(0, 0);
    const ivec2 endR = ivec2(1, 0);
    const ivec2 endU = ivec2(5, 2);
    const ivec2 endD = ivec2(5, 1);
    const ivec2 isolated = ivec2(2, 0);

    ivec2 map () {
      float r = rng();
      bool valueSelf = value(0, 0);
      bool valueBottom = value(0, -1);
      bool valueUp = value(0, 1);
      bool valueLeft = value(-1, 0);
      bool valueRight = value(1, 0);

      if (!valueSelf) {
        return valueUp ? (r < 0.97 ? fallTile : fallTileVar1) : (r < 0.97 ? voidTile : voidTileVar1);
      } else {
        if (!valueBottom && valueUp && valueLeft && valueRight) {
          return r < 0.9 ? edgeD : (r < 0.95 ? edgeDVar1 : edgeDVar2);
        }

        if (!valueUp && valueBottom && valueLeft && valueRight) {
          return r < 0.9 ? edgeU : (r < 0.95 ? edgeUVar1 : edgeUVar2);
        }

        if (!valueLeft && valueUp && valueBottom && valueRight) {
          return r < 0.9 ? edgeL : (r < 0.95 ? edgeLVar1 : edgeLVar2);
        }

        if (!valueRight && valueUp && valueBottom && valueLeft) {
          return r < 0.9 ? edgeR : (r < 0.95 ? edgeRVar1 : edgeRVar2);
        }

        if (!valueLeft && !valueUp && valueBottom && valueRight) {
          return cornerUL;
        }

        if (!valueLeft && !valueBottom && valueUp && valueRight) {
          return cornerDL;
        }

        if (!valueRight && !valueUp && valueBottom && valueLeft) {
          return cornerUR;
        }

        if (!valueRight && !valueBottom && valueUp && valueLeft) {
          return cornerDR;
        }

        if (valueRight && !valueLeft && !valueUp && !valueBottom) {
          return endL;
        }

        if (valueLeft && !valueRight && !valueUp && !valueBottom) {
          return endR;
        }

        if (valueBottom && !valueLeft && !valueUp && !valueRight) {
          return endU;
        }

        if (valueUp && !valueRight && !valueLeft && !valueBottom) {
          return endD;
        }

        if (!valueLeft && !valueRight && !valueUp && !valueBottom) {
          return isolated;
        }

        if (valueLeft && valueRight && !valueUp && !valueBottom) {
          return lineH;
        }

        if (!valueLeft && !valueRight && valueUp && valueBottom) {
          return lineV;
        }
      }

      return r < 0.97 ? groundTile : groundTileVar1;
    }

    void main () {
      if (useTiles > 0.5) {
        ivec2 inTileCoord = ivec2(mod(gl_FragCoord.xy, vec2(16.)));
        fragColor = texelFetch(textureTiles, map() * 16 + inTileCoord, 0);
      } else {
        fragColor = vec4(vec3(value(0, 0)), 1.);
      }
    }
    `,
    {
      backgroundTexture: 't',
      textureTiles: 't',
      resolution: '2f',
      useTiles: 'f'
    }
  );

  convchain.context.setCanvasSize(40 * 16, 40 * 16);

  var display = function display () {
    convchain.context.draw(program, {
      resolution: [convchain.width, convchain.height],
      backgroundTexture: texture,
      textureTiles: options.useTiles > 1 ? textureTiles2 : textureTiles1,
      useTiles: 0
    }, null);
  };

  var iterationElement = document.getElementById('iteration');

  var texture = null;
  var i = 0;
  var iterating = false;
  var forceDisplay = false;
  var changed = false;

  document.getElementById('reset').addEventListener('click', function () {
    texture = null;
    changed = false;
    i = 0;
    iterationElement.innerText = '0 + 0000';
    convchain.setField(40, 40);
  });

  document.getElementById('play').addEventListener('click', function () {
    iterating = !iterating;
    document.getElementById('play').innerText = iterating ? 'Stop' : 'Start';
  });

  document.getElementById('next').addEventListener('click', function () {
    iterating = false;
    _compute();
    _display();
  });

  function _compute () {
    texture = convchain.iterate(1, options.receptorSize, options.temperature);
    i += Math.pow(40 / options.receptorSize, 2) | 0;
  }

  function _display () {
    var remainder = (i % (40 * 40));
    iterationElement.innerText = (i / (40 * 40) | 0) + ' + ' + '0000'.substr(0, 4 - remainder.toString().length) + remainder;
    display();
  }

  var loop = function loop () {
    requestAnimationFrame(loop);
    if (iterating) {
      _compute();
    }

    if (iterating || forceDisplay) {
      _display();
      forceDisplay = false;
    }
  };

  requestAnimationFrame(loop);

  var inputs = document.querySelectorAll('.field input');

  for (let input of inputs) {
    const valueLabel = input.parentNode.querySelector('.value');
    const option = input.id;

    input.addEventListener('input', function () {
      options[option] = parseFloat(input.value);

      if (option === 'sampleWidth' || option === 'sampleHeight') {
        resizeSample();
      }

      if (option === 'useTiles') {
        forceDisplay = true;
        valueLabel.innerText = options[option] ? 'Tile set #' + options[option] : 'None';
      } else {
        valueLabel.innerText = input.value;
      }
    });
  }

}
</script> <link defer="" rel="stylesheet" href="/assets/css/convchain.css?9fd9801e5b882bfdc80da2bc8badbb49"/> </div>]]></content><author><name></name></author><category term="personal-site"/><category term="software-dev"/><category term="procgen"/><summary type="html"><![CDATA[A not-so-gentle introduction to programming procedural generation with an interactive demo]]></summary></entry><entry><title type="html">My Site is Up and Running again</title><link href="https://nearground.github.io/blog/2025/my-site-is-up-and-running-again/" rel="alternate" type="text/html" title="My Site is Up and Running again"/><published>2025-07-30T00:51:00+00:00</published><updated>2025-07-30T00:51:00+00:00</updated><id>https://nearground.github.io/blog/2025/my-site-is-up-and-running-again</id><content type="html" xml:base="https://nearground.github.io/blog/2025/my-site-is-up-and-running-again/"><![CDATA[<p>I‚Äôve recently been obsessing over game design, especially procedural generation algorithms. One that caught my eye early on is called Wave Function Collapse. It‚Äôs a little bit of a sensationalist name, but it really is inspired after quantum mechanics. I‚Äôm working through a few tutorials on how to implement this on javascript so I can post it on the site, then I‚Äôll make the leap to C# with Unity in order to use it for level generation. Lately, BorisTheBrave and InformationPhilosopher have been a giant source of inspiration. <a href="https://www.boristhebrave.com/">https://www.boristhebrave.com/</a> <a href="https://www.informationphilosopher.com/">https://www.informationphilosopher.com/</a></p>]]></content><author><name></name></author><category term="personal-site"/><category term="software-dev"/><category term="procgen"/><summary type="html"><![CDATA[Whoo!]]></summary></entry><entry><title type="html">How To Create a Personal Website and Blog for Free</title><link href="https://nearground.github.io/blog/2023/how-this-site-was-built/" rel="alternate" type="text/html" title="How To Create a Personal Website and Blog for Free"/><published>2023-08-30T01:11:44+00:00</published><updated>2023-08-30T01:11:44+00:00</updated><id>https://nearground.github.io/blog/2023/how-this-site-was-built</id><content type="html" xml:base="https://nearground.github.io/blog/2023/how-this-site-was-built/"><![CDATA[<h2 id="adding-a-headless-cms-to-your-jekyll-theme">Adding a headless CMS to your Jekyll theme</h2> <p>I want to share with you how I publish my blog to Github pages. It‚Äôs been a while since I originally wrote this article, titled ‚ÄúHow to build your own website and host it for free‚Äù. However, most of the steps involved just a recap of setting up the Jekyll template <a href="https://github.com/alshedivat/al-folio">alshedivat/al-folio</a> <code class="language-plaintext highlighter-rouge">al-folio</code>. While it comes with its own set of quirks, most if not all of them can be solved by going searching in the discussions for your particular bug. One feature that is sorely missing from this template is the ability to edit and publish your own content, so this is what we‚Äôll cover here. We will use a headless CMS called <a href="https://github.com/decaporg/decap-cms">Decap CMS</a>, and a CMS authentication system, both free for use.</p> <h2 id="decap-cms">Decap CMS</h2> <ol> <li>In the root folder, create an <code class="language-plaintext highlighter-rouge">admin</code> folder. We‚Äôll add two files there:</li> </ol> <div class="language-markdown highlighter-rouge"><div class="highlight"><pre class="highlight"><code>admin
‚îú index.html
‚îî config.yml
</code></pre></div></div> <p><code class="language-plaintext highlighter-rouge">index.html</code></p> <div class="language-markdown highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nn">---</span>
<span class="na">layout</span><span class="pi">:</span> <span class="s">default</span>
<span class="na">title</span><span class="pi">:</span> <span class="s">Admin</span>
<span class="na">permalink</span><span class="pi">:</span> <span class="s">/admin/</span>
<span class="na">subtitle</span><span class="pi">:</span> <span class="s">login screen for decap</span>
<span class="na">title</span><span class="pi">:</span> <span class="s">Login</span>
<span class="na">nav</span><span class="pi">:</span> <span class="kc">true</span>
<span class="na">nav_order</span><span class="pi">:</span> <span class="m">10</span>
<span class="na">dropdown</span><span class="pi">:</span> <span class="kc">false</span>
<span class="na">publish_mode</span><span class="pi">:</span> <span class="s">editorial_workflow</span>
<span class="na">media_folder</span><span class="pi">:</span> <span class="s2">"</span><span class="s">assets/uploads"</span>
<span class="nn">---</span>

<span class="cp">&lt;!doctype html&gt;</span>
<span class="nt">&lt;html&gt;</span>
<span class="nt">&lt;head&gt;</span>
  <span class="nt">&lt;meta</span> <span class="na">charset=</span><span class="s">"utf-8"</span> <span class="nt">/&gt;</span>
  <span class="nt">&lt;meta</span> <span class="na">name=</span><span class="s">"viewport"</span> <span class="na">content=</span><span class="s">"width=device-width, initial-scale=1.0"</span> <span class="nt">/&gt;</span>
  <span class="nt">&lt;meta</span> <span class="na">name=</span><span class="s">"robots"</span> <span class="na">content=</span><span class="s">"noindex"</span> <span class="nt">/&gt;</span>
  <span class="nt">&lt;title&gt;</span>Content Manager<span class="nt">&lt;/title&gt;</span>
<span class="nt">&lt;/head&gt;</span>
<span class="nt">&lt;body&gt;</span>
  <span class="c">&lt;!-- Include the script that builds the page and powers Decap CMS --&gt;</span>
  <span class="nv">&lt;script src="https://unpkg.com/decap-cms@^3.0.0/dist/decap-cms.js"&gt;&lt;/script&gt;</span>
<span class="nt">&lt;/body&gt;</span>
<span class="nt">&lt;/html&gt;</span>
</code></pre></div></div> <p><code class="language-plaintext highlighter-rouge">config.yml</code></p> <div class="language-markdown highlighter-rouge"><div class="highlight"><pre class="highlight"><code>backend:
name: github
branch: main # Branch to update (whatever is your default branch. If left blank it uses master)
repo: your-repo/your-repo.github.io

publish_mode: editorial_workflow
media_folder: "assets/img/uploads"
public_folder: static/media

collections:
<span class="p">
-</span> name: "blog" # Used in routes, e.g., /admin/collections/blog
  label: "Blog" # Used in the UI
  folder: "<span class="se">\_</span>posts" # The path to the folder where the documents are stored
  create: true # Allow users to create new documents in this collection
  slug: "---" # Filename template, e.g., YYYY-MM-DD-title.md
  fields: # The fields for each document, usually in front matter
<span class="p">  -</span> {label: "Layout", name: "layout", widget: "hidden", default: "post"}
<span class="p">  -</span> {label: "Comments", name: "gisqus_comments", widget: "hidden", default: "true"}
<span class="p">  -</span> {label: "Title", name: "title", widget: "string"}
<span class="p">  -</span> {label: "Publish Date", name: "date", widget: "datetime"}
<span class="p">  -</span> {label: "Description", name: "description", widget: "string"}
<span class="p">  -</span> {label: "Body", name: "body", widget: "markdown"}
<span class="p">  -</span> {label: "Tags", name: "tags", widget: "markdown"}
<span class="p">  -</span> {label: "Categories", name: "categories", widget: "markdown"}
<span class="p">  -</span> {label: "related", name: "related_posts", widget: "hidden", default: "false"}
<span class="p">
-</span> name: "news"
  label: "News"
  folder: "posts"
  create: true
  fields:
<span class="p">  -</span> {label: "Layout", name: "layout", widget: "hidden", default: "post"}
<span class="p">  -</span> {label: "Comments", name: "gisqus_comments", widget: "hidden", default: "true"}
<span class="p">  -</span> {label: "Publish Date", name: "date", widget: "datetime"}
<span class="p">  -</span> {label: "Body", name: "body", widget: "markdown"}
<span class="p">  -</span> {label: "gisqus", name: "giscus_comments", widget: "hidden", default: "true"}
    inline: true
</code></pre></div></div> <p>This config file tells the CMS that we have two different collections of posts that we want to be able to create. It requires some kinds of fields, and others are conventions that <code class="language-plaintext highlighter-rouge">al-folio</code>‚Äôs posts already follow. You can add/edit to this list to some degree, like adding another collection for publishing your own book reviews.</p> <p>Once you rebuild the website with docker-compose, you‚Äôll notice you have a login button on your site. It won‚Äôt work out of the box because we‚Äôre not on Netlify due to OAuth requirements, so we‚Äôll create one ourselves.</p> <h4 id="adding-oauth">Adding OAuth</h4> <p>Luckily for us, we can run OAuth logic for free with the help of <code class="language-plaintext highlighter-rouge">sveltia</code>, a CMS authenticator that relies on an also-free Cloudflare workers script.</p> <p><a href="https://github.com/sveltia/sveltia-cms-auth">Follow this tutorial</a></p> <p>Make sure to follow the tutorial exactly, or you won‚Äôt be able to make sense of what went wrong.</p> <h4 id="conclusion">Conclusion</h4> <p>There ya go. If I‚Äôm missing something feel free to request it.</p>]]></content><author><name></name></author><category term="personal-site"/><category term="jekyll"/><category term="blog"/><summary type="html"><![CDATA[How to build a blog on Github Pages]]></summary></entry></feed>